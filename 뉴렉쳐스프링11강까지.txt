
인터넷이 동작하기 위한 기본적 원리: 

서로 다른 컴퓨터가 서로 정보를 주고받기 위한 것.
웹서버가 설치된 컴퓨터: 도메인과 하드디스크- 저장소 존재
웹브라우저가 설치된 컴퓨터는 인터넷을 통해 전기적인 신호를 해당 도메인이 부여된 컴퓨터에 보냄. 특정 도메인을 가진 사이트를 달라고 요청.
웹서버가 설치된 컴퓨터는 그 웹사이트 파일을 코드로 보냄. (응답)
웹브라우저는 그것을 받아서 읽어 출력. 

웹서버와 웹브라우저는 서로 정보를 주고받음.

HTTP 프로토콜
HTTP: 서버와 클라이언트가 통신할 때 지켜야 할 통신 규약.
http header: 



-------------------------------------------------------

메이븐: 프로젝트 빌드 관리 툴.
 빌드 과정(프로젝트 만들고, 라이브러리 설정하고, 컴파일하고, 테스트하고, 패키지 만들고, 배포하고 ...)에서 반복되는 일들을 효과적으로 처리할 수 있도록 도와주는 툴. 프로젝트에서 필요한 xml, properties, jar파일들 등을 자동으로 인식해서 빌드해 줌. 외부 라이브러리 참조도 자동으로. 빌드과정을 경량화할 수 있음.

메이븐의 특징: xml 기반으로 빌드. 프로젝트의 외부 라이브러리를 쉽게 참조할 수 있게 pom.xml파일로 명시하여 관리함. 참조한 외부라이브러리에 연관된 다른 라이브러리도 자동으로 관리됨. 소스코드를 컴파일, 테스트, 패키징 과정을 해주고 그때 산출되는 class파일 등을 target 폴더에 저장. (target 폴더는 이렇듯 빌드할 때 쓰는 폴더라 버전관리를 하면 안됨 !! 이그노어 처리 해주기.)

dependencies: 해당 프로젝트에서 의존성을 가지고 사용하는 라이브러리를 정의하는 영역 태그. 각 라이브러리는 dependency 태그로 구분. (((메이븐 레파지토리 사이트에서 코드를 제공하니 그냥 그걸 복붙하면 돌아감)))


----------------------------------------------

텍스트로 구조화된 정보를 나타낼 수 있는 데이터구조들. 사용해본 것은 아래와 같다.

xml
xml은 html 코드처럼 태그를 사용하는 방식. 각 태그명은 데이터의 항목명이 되고, 태그 안에 태그가 중첩으로 사용될수도 있음. 2차원배열, 그리고 그것이 중첩으로 이루어진 다양한 데이터를 표현할 수 있음. 일일히 태그들을 열고 닫아야 한다는 단점. 빌드 툴이 없으면 태그에 오타를 낼 수 있다는 단점. 다만 오타 낸 태그 이외의 파일들은 정상작동함. (json은 오타 하나 나면 파일이 먹통.) 또한 주석 태그를 쓸 수가 있고, 각 사용처마다 요구된 구조화를 잘 갖추었는지 스키마로 확인 가능 (xsd 형식) 하다는 장점이 있음.

json
json은 자바스크립트의 객체표기법을 이용함. 간결하고 작성하기 쉬워 많은 분야에서 json은 xml을 대체할 수 있음. 하지만 문법 오류에 취약하다는 단점. 콤마나 대괄호 하나를 잘못 넣으면 파일 전체가 먹통. 

properties
키=값의 형태로 파라미터 정보들을 저장하기 위한 파일 형식. 변경 가능한 문자열을 별도의 properties 파일에 작성해두고 프로그램 내에서 호출하는 형태로 많이 쓰임. 컴파일 후 재실행 과정을 거치지 않기 때문에 오류 발생 가능성이 줄어듬.

java.util.properties.class를 사용하여 객체를 생성한 뒤, getProperty메소드로 꺼내쓰자.

---------------------------------------------


DAO: database의 data에 access하는 트랜잭션 객체. 저수준의 로직과 고급 비즈니스 로직을 분리하고 도메인 로직으로부터 ~~를 숨기기 위해 사용. 
트랜잭션: 업무처리의 최소 단위. 정상적으로 처리되면 커밋, 오류 발생하면 롤백해야 함. 복잡한 응용프로그래밍에서 갱신 도중 중단 시 발생할 수 있는 데이터 부정합을 방지하기 위해 사용.

Java EE: se 플랫폼 위에 구축되어 네트워크 애플리케이션을 개발, 실행하기 위한 api 및 런타임 환경 제공. servlet, json, api, 웹소켓 등 지원.
Spring이 JavaEE를 대체. 자바 EE가 제공하는 영역을 스프링이 더 잘 처리할 수 있음.


인터페이스 사용 - 인터페이스는 다양하게
객체 생성과 조립을 위한 외부 설정: 클래스와 클래스간 어떤 파일을 결합할것인가, 에 대한 부분을 외부파일로 빼, 나중에 수정이 일어났을 경우 그 부분만 수정해도 괜찮게 하기. 이때 사용하는 두가지 방법이 XML, 어노테이션.
XML, Annotation.

의존이란: 객체 간의 의존. 이게 무슨 뜻이냐면, 한 클래스가 로직을 처리하기 위해 다른 클래스를 무조건 사용해야 하는 상황. 우리가 jsp를 배울 때 logindao는 user클래스를 참조하고, loginservice는 logindao를 사용하고, loginHandler는 loginService를 사용하고 .... 이렇듯 한 클래스가 다른 클래스의 메소드를 쓸 때 이것을 의존한다고 표현함. loginHandler 클래스는 loginService를 의존. 클래스 안에서 의존하는 객체를 new 생성자로 생성하면 코드 작성이 쉽긴 하나, 유지보수에서 문제점을 유발할 수 있음. 코드의 변경이 필요할 때 의존하는 객체와 의존받는 객체 모두를 수정해야 하는 문제. 만약 그것이 수십개라면? 아주 골치아픈 문제.

DI(Depencency Injection): 의존성 주입. 의존성 낮추기.객체를 생성하는 것이 아니라, 의존하는 객체를 전달받는 것이다.  일체형이 아닌 조립형을 사용. 조립형의 장점은, 부품을 쉽게 바꿀 수 있다는 장점. 부품을 조립해야 하는 과정이 들어간다는 방법. 조립 방법은 세터를 통하는 방법, 생성자를 통해 주입한 방법. 근데 그 과정이 번거로움. 이것을 스프링의 도움을 받을 것임.

IOC: Inversion of Control. 제어의 역전. 메소드나 객체의 호출작업을 개발자가 결정하는 것이 아니라 외부에서 결정되는 것. 부품들이 조립되어 담겨있는 것. 



DI를 위해 의존객체를 전달받는 정보를 명시하는 방법 두가지. 1. xml 파일 이용. 2. 어노테이션.
 

------------------------------------
//
생성자 DI 방식 / 메소드 DI 방식
생성자 방식: 빈 객체를 생성하는 시점에 모든 의존객체가 주입됨. (어떤 의존객체가 설정되는지 알아내려면 생성자의 코드를 봐야 함)

메소드 DI 방식: 세터 메소드 이름을 통해 어떤 의존객체가 주입되는 지 알 수 있음. (다만 세터 메소드를 사용해서 의존객체를 전달받지 않더라도 빈 객체가 생성되기 때문에 객체를 사용하는 시점에 null익셉션이 발생할 수 있음.)

생성자 방식이 더 선호되는 듯 함.


--------------------------------

ApplicationContext의 종류
- ClassPathXmlApplicationContext
- FileSystemXmlApplicationContext
- XmlWebApplicationContext
- AnnotationConfigApplicationContext

자바Configuration 파일로 설정한 걸 사용할 땐
ApplicationContext context = new AnnotationConfigApplicationContext(클래스이름.class);
로 사용하기




----------------------------------------------------------
(xml)
이는 자바로 작성할 수 있음. 자바 config라고. 자바와 xml을 병행해 사용하는 것보단 자바만으로 구성하는 것이 더 권장됨.


스프링은 Bean이라는 태그를 이용해 생성할 객체를 지시할 수 있음. 
스프링 빈: 스프링 컨테이너에 의해 관리되는 자바객체(POJO).
스프링 컨테이너: 스프링빈의 생명주기를 관리하며, 생성된 스프링빈들에게 추가적인 기능을 제공. IOC와 DI의 원리가 스프링 컨테이너에 적용됨. 객체를 생성하고 소멸하는 객체의 생성주기 단계의 관리를 스프링 컨테이너가 대신해줌. 즉, 제어흐름을 외부에서 관리하게 되는 것이며 객체들 간의 의존 관계를 런타임 과정에서 스프링이 알아서 만들어주는 것.

이하 XML 태그 안::

어떤 클래스를 객체화할것인지, 어떤 이름으로 쓸 것인지 정할 수 있음. 생성할 객체명을 쓸 수 있고 ,,, 동명이인을 방지하기 위해 클래스 속성에는 패키지명까지 같이 써줘야 함.
Bean id = 변수명, class = 클래스 이름(패키지 명시해야 함)
property태그로 세터 함수를 작성할 수 있음. 원래 패키지에 세터가 무조건 있어야 함 ! ! 
name = 세터의 함수명. value = 파라미터로 주입할 객체의 이름.(bean으로 등록한 id), ref = ;


생성자에 파라미터로 값을 받아와야 할 경우 constructor-arg 태그로 파라미터를 넣을 수 있음. 생성자에 들어갈 파라미터 순서대로 constructor-arg를 세팅. 인덱스 지정 가능. (이것도 파라미터 순.) name 속성으로 조금 더 명시적으로 적을 수도 있음. type 속성으로 데이터타입 지정 가능.
Namespaces도 사용 가능 ... 이건 나중에 더 알아보쟈....
ex: <constructor-arg name = "kor" value = "10"/>

ApplicationContext context = new ClassPathXmlApplicationContext("config.xml");
context 객체가 생성한 bean을 읽어옴. getBean로 그것을 호출할 수 있음.

<context:annotation-config/>
bean을 만들고 나면, 그 bean을 autowired하는 어노테이션이 있나 살펴보고 있으면 autowired하라는 명령. 이것이 없으면 @Autowired 어노테이션을 사용할 수 없음 ! 
<context:component-scan base-pakage = "패키지명"/>
@Component 어노테이션을 사용한다면 해당 xml 태그를 사용해 지정해줘야 스프링이 해당 패키지에 가서 컴포넌트 객체가 있는지 스캔을 함. @Component 어노테이션을 사용할 때의 필수 설정. 여러 패키지에서 스캔해야 하는 경우, "패키지명, 패키지명" 식으로 콤마로 구분

Collection객체를 DI로 다루기
id는 자기가 정하고, class에는 Collection 객체가 저장된 클래스명(패키지명 포함)을 명시.
list 태그를 이용해 정적인 방식으로 초기화하고자 하는 객체를 추가할 수 있음. 예를 들어, 위에서 만든 Bean을 추가할 수 있음. 혹은 새 빈을 만들거나.
ref 태그: 레퍼런스.


bean을 호출해주는 getBean()은 첫번째 파라미터로 빈의 이름(String 타입), 두번째 파라미터로 빈의 타입(class 타입)을 받음.
ex) UserDao ud = context.getBean("userDao", UserDao.class)

bean의 이름을 지정하지 않고 타입만으로 호출할 때, 해당 타입의 빈 객체가 한개만 존재하면 해당 빈을 구해서 리턴. 여러개가 존재해도 리턴. (해당 타입의 빈 객체가 한개 이상 존재할 경우 이름으로 구별해주기.)


--------------------------------------------------------

(어노테이션 - Autowired와 qualifier)
어노테이션의 장점: xml의 사용은 의존된 객체가 바뀌면 xml파일을 열어서 설정을 바꿔야 함. 어노테이션은 이러한 설정을 메타데이터로서 설정파일조차 없이 객체 변경에서의 업데이트가 용이함. xml은 설정파일을 분리. 어노테이션은 코드에 간단하게 표시.

@Autowired
필요한 의존 객체의 타입에 해당하는 "Bean"을 찾아 자동으로 주입해줌. 자동주입. 의존성 주입을 할 대상을 찾지 못한다면 어플리케이션 구동이 실패.

autowired의 구동원리: 만들어진 Bean에서 해당하는 자료형과 부합하는 개체를 찾아오는 것. 만약 같은 자료형의 Bean이 둘 이상이라면 변수명과 bean의 id값이 같은 것을 찾아옴. 없으면 에러.

이러한 변수명 설정을 @Qualifier 어노테이션으로 따로 빼서 기입할 수 있음. 이것을 작성하면, 변수명이 상이하더라도 자료형과 @Qualifier로 명시한 id값이 같은 Bean을 @Autowired가 찾아줌.

@Autowired는 setter, 생성자, 필드에 지시하여 인젝션할 수 있음. 이 세가지가 조금 차이가 있음.
 
-생성자에 오토와이어드 할 때에는 파라미터가 여러개 존재할 수 있는 고로, 각 파라미터 마다 앞에 @Qualifier 어노테이션을 사용하여 명시해주기.
-필드에 지시할 때에는 그에 걸맞는 생성자가 존재해야 함.
-세터에 사용할 때엔 별 주의점이 없음. 




Autowired의 변수명
- required: 해당하는 빈이 무조건 필요한지의 여부를 설정하는 변수. 값은 true 혹은 false로 두며, 기본값은 true.

@Import(클래스명.class) 애노테이션은 함께 사용할 설정 클래스(config클래스)를 지정한다. 자바 배열을 이용하여 두개 이상의 설정 클래스를 지정할수도 있다. ({클래스명.class, 다른클래스명.class})

-----------------------------------------------------------------

어노테이션을 이용한 객체 생성
(Component, Controller, Service, Repository)

클래스 위에 @Component 어노테이션을 쓰면 해당 클래스는 객체화 됨. 객체 이름을 명명할 수 있음. (xml에서 했었던 id.)
필드에 붙이는 @Value 어노테이션을 이용해 원하는 필드값으로 초기화를 할 수 있음.
@Value 문법: @Value("초기화값")



@Component (MVC 방식으로 웹어플리케이션을 만들 경우, 그 MVC를 구성하고 있는 자바 코드, 업무형 로직을 가지고 있는 그 코드들을 컴포넌트라고 함.)
  의미를 가지고 어노테이션을 쓸 수 있는데 다음과 같은 세가지. 역할로서 의미가 부여됨. 이건 이를테면 HTML5에서 div 태그와 시멘틱 태그들과의 관계와 같음.
  - @Controller: 사용자의 입출력 담당. 요청과 응답 처리. 스프링 MVC컨트롤러를 의미.
  - @Service: 사용자의 요구사항에 맞는 서비스 제공. 특별한 처리는 없으나 개발자들이 핵심 비즈니스 계층을 인식하는데에 도움을 줌.
  - @Repository: Dao의 역할 (database의 data에 access하는 트랜잭션 객체.) 스프링 접근계층. 해당 계층에서 발생되는 예외는 모두 DataAccessException으로 변환됨.


---------------------------------------------------------------------

자바 Configuration

xml을 대신할 수 있는 설정 파일. 설정을 위한 자바 클래스임을 표시하기 위해 @Configration 어노테이션을 사용함. 
@ComponentScan("패키지명")을 사용해 어떤 패키지를 대상으로 한 설정 파일인지 밝힘.

@Bean 어노테이션을 생성해 객체를 생성하도록 지시. 이건 메소드라기보단 하나의 문법이라고 생각하면 편함.
	이런 Bean이 있다 치자,

	@Bean
 	public User user() {
		return new User();
	}

	반환형: 클래스 이름
	메소드 명: Bean의 id
	반환값: 생성된 객체

	로 이해하자.

스프링 컨테이너는 별도의 설정을 하지 않을 경우 싱글톤 객체를 생성한다; 단일객체라는 의미. @Bean이 붙은 객체는 하나만 생성되며, 몇번을 호출하더라도 항상 같은 객체를 리턴한다.


